########调度器

1.Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。

2.历史

1.单线程调度器 0.x
只包含 40 多行代码；
程序中只能存在一个活跃线程，由 G-M 模型组成；

2.多线程调度器 1.0
允许运行多线程的程序；
全局锁导致竞争严重；

3.任务窃取调度器 1.1
引入了处理器 P，构成了目前的 G-M-P 模型；
在处理器 P 的基础上实现了基于工作窃取的调度器；
在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；
时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；

4.抢占式调度器 · 1.2 ~ 至今
基于协作的抢占式调度器 - 1.2 ~ 1.13
通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；
Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；

基于信号的抢占式调度器 - 1.14 ~ 至今
实现基于信号的真抢占式调度；
垃圾回收在扫描栈时会触发抢占调度；
抢占的时间点不够多，还不能覆盖全部的边缘情况；


3.任务窃取调度器


4.G-M-P 模型

基于工作窃取的多线程调度器将每一个线程绑定到了独立的 CPU 上，这些线程会被不同处理器管理，不同的处理器通过工作窃取对任务进行再分配实现任务的平衡，也能提升调度器和 Go 语言程序的整体性能，今天所有的 Go 语言服务都受益于这一改动。

5.抢占式调度器
对 Go 语言并发模型的修改提升了调度器的性能，但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。
Go 语言的调度器在 1.2 版本4中引入基于协作的抢占式调度解决下面的问题
    某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿；
    垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间6，导致整个程序无法工作；

1.2 版本的抢占式调度虽然能够缓解这个问题，但是它实现的抢占式调度是基于协作的，在之后很长的一段时间里 Go 语言的调度器都有一些无法被抢占的边缘情况，例如：for 循环或者垃圾回收长时间占用线程，这些问题中的一部分直到 1.14 才被基于信号的抢占式调度解决。

我们可以在 pkg/runtime/proc.c 文件中找到引入基于协作的抢占式调度后的调度器。
Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。
因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种协作式的抢占式调度。

6.基于信号的抢占式调度
该信号需要被调试器透传；
该信号不会被内部的 libc 库使用并拦截；
该信号可以随意出现并且不触发任何后果；
我们需要处理多个平台上的不同信号；
STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能8。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决所有问题，但是这种真抢占式调度是调度器走向完备的开始，相信在未来我们会在更多的地方触发抢占。

7.Goroutine 的状态

_Grunnable、_Grunning、_Gsyscall、_Gwaiting 和 _Gpreempted


8.CPU 和活跃线程
