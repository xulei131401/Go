########定时器底层源码分析


1.设计原理
Go 语言从实现计时器到现在经历过很多个版本的迭代，到最新的版本为止，计时器的实现分别经历了以下几个过程：

Go 1.9 版本之前，所有的计时器由全局唯一的四叉堆维护；
Go 1.10 ~ 1.13，全局使用 64 个四叉堆维护全部的计时器，每个处理器（P）创建的计时器会由对应的四叉堆维护；
Go 1.14 版本之后，每个处理器单独管理计时器并通过网络轮询器触发；
我们在这一节会分别介绍计时器在不同版本的不同设计，梳理计时器实现的演进过程。

2.全局四叉堆
var timers struct {
    lock         mutex
    gp           *g
    created      bool
    sleeping     bool
    rescheduling bool
    sleepUntil   int64
    waitnote     note
    t            []*timer
}

这个结构体中的字段 t 就是最小四叉堆，运行时创建的所有计时器都会加入到四叉堆中。runtime.timerproc:093adee Goroutine 会运行时间驱动的事件，运行时会在发生以下事件时唤醒计时器：

四叉堆中的计时器到期；
四叉堆中加入了触发时间更早的新计时器；

3.计时器四叉堆

然而全局四叉堆共用的互斥锁对计时器的影响非常大，计时器的各种操作都需要获取全局唯一的互斥锁，这会严重影响计时器的性能4。


4.分片四叉堆
Go 1.10 将全局的四叉堆分割成了 64 个更小的四叉堆5。在理想情况下，四叉堆的数量应该等于处理器的数量，但是这需要实现动态的分配过程，所以经过权衡最终选择初始化 64 个四叉堆，以牺牲内存占用的代价换取性能的提升。

如果当前机器上的处理器 P 的个数超过了 64，多个处理器上的计时器就可能存储在同一个桶中。每一个计时器桶都由一个运行 runtime.timerproc:76f4fd8 函数的 Goroutine 处理。


5.分片计时器桶
将全局计时器分片的方式，虽然能够降低锁的粒度，提高计时器的性能，但是 runtime.timerproc:76f4fd8 造成的处理器和线程之间频繁的上下文切换却成为了影响计时器性能的首要因素6。

网络轮询器 #
在最新版本的实现中，计时器桶已经被移除7，所有的计时器都以最小四叉堆的形式存储在处理器 runtime.p 中。


6.网络轮询器
处理器 runtime.p 中与计时器相关的有以下字段：

timersLock — 用于保护计时器的互斥锁；
timers — 存储计时器的最小四叉堆；
numTimers — 处理器中的计时器数量；
adjustTimers — 处理器中处于 timerModifiedEarlier 状态的计时器数量；
deletedTimers — 处理器中处于 timerDeleted 状态的计时器数量；
















