package main

import (
	_ "fmt"
)

// 定义一个简单的结构体
type User struct {
	name    string
	age     int
	webSite string
}

/**
内存逃逸分析：
分析工具:
1.通过编译工具查看详细的逃逸分析过程(go build -gcflags '-m -m -l' escape1.go)
2.通过反编译命令查看go tool compile -S escape1.go
编译参数介绍(-gcflags):

-N: 禁止编译优化
-l: 禁止内联(可以有效减少程序大小)
-m: 逃逸分析(最多可重复四次)
-benchmem: 压测时打印内存分配统计


	结论:	1.如果一个函数返回一个对变量的引用，那么它就会发生逃逸;简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：如果函数外部没有引用，则优先放到栈中；如果函数外部存在引用，则必定放到堆中；
			2.静态分配到栈上，性能一定比动态分配到堆上好
			3.底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心
			4.每个 Go 版本的逃逸分析都会有所不同（会改变，会优化)
			5.直接通过go build -gcflags '-m -l' 就可以看到逃逸分析的过程和结果
			6.到处都用指针传递并不一定是最好的，要用对
			7.map & slice 初始化时，预估容量，避免由扩展导致的内存分配。但是如果太大（10000）也会逃逸，因为栈的空间是有限的

	逃逸类型:
			1.指针逃逸
			2.动态类型逃逸，比如:interface，编译期间很难确定其参数的具体类型，也能产生逃逸
			3.如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上
			4.尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上

	如何避免
			1.go 中的接口类型的方法调用是动态调度，因此不能够在编译阶段确定，所有类型结构转换成接口的过程会涉及到内存逃逸的情况发生。如果对于性能要求比较高且访问频次比较高的函数调用，应该尽量避免使用接口类型
			2.由于切片一般都是使用在函数传递的场景下，而且切片在 append 的时候可能会涉及到重新分配内存，如果切片在编译期间的大小不能够确认或者大小超出栈的限制，多数情况下都会分配到堆上

	总结
			1.堆上动态分配内存比栈上静态分配内存，开销大很多。
			2.变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。
			3.Go编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。简单来说，编译器会根据变量是否被外部引用来决定是否逃逸。
			4.对于Go程序员来说，编译器的这些逃逸分析规则不需要掌握，我们只需通过go build -gcflags '-m’命令来观察变量逃逸情况就行了
			5.不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。
*/
func main() {
	// 初始化user结构体的指针对象
	//u := &User{"BGBiao", 18, "https://bgbiao.top"}
	//GetUserInfo(u)
	//GetName(u)

	//fmt.Println(GetUserInfo(u))
	//fmt.Println(GetName(u))

	u1 := &User{"BGBiao", 18, "https://bgbiao.top"}
	GetUserInfo1(*u1)
}

// GetUserInfo 获取用户信息
func GetUserInfo(u *User) *User {
	return u
}

func GetUserInfo1(u User) *User {
	return &u
}

// GetName 获取用户名称
func GetName(u *User) string {
	return u.name
}
